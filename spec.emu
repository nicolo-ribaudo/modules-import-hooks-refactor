<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Modules Host Hooks Refactor
stage: -1
contributors: Nicol√≤ Ribaudo
</pre>

<!--
Idea adapted from @ljharb, but avoiding multiple equal ids.
https://github.com/rricard/proposal-symbol-predicates/blob/7c8c661604d89c3af7a83461d3631bf810fa3487/spec.emu#L13-L24
-->
<style>
[id^="sec-placeholder"], [href^="#sec-placeholder"] {
  display: none;
}
</style>
<script>
  Array.from(document.querySelectorAll('ol.toc li'), function (node) {
    if (node.querySelector(':scope > [href^="#sec-placeholder"]')) {
      node.style.display = 'none';
    }
  });
</script>

<emu-clause id="sec-placeholder-1"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-2"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-3"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-4"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-5"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-6"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-7"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-8"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-9"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-10"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-11"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-12"><h1></h1></emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-placeholder-13.1"><h1></h1></emu-clause>
  <emu-clause id="sec-placeholder-13.2"><h1></h1></emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>Left-Hand-Side Expressions</h1>

    <emu-clause id="sec-placeholder-13.3.1"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.2"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.3"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.4"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.5"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.6"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.7"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.8"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.9"><h1></h1></emu-clause>

    <emu-clause id="sec-import-calls">
      <h1>Import Calls</h1>

      <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `)`</emu-grammar>
        <emu-alg>
          1. Let _referencingScriptOrModule_ be GetActiveScriptOrModule().
          1. Let _argRef_ be the result of evaluating |AssignmentExpression|.
          1. Let _specifier_ be ? GetValue(_argRef_).
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _specifierString_ be Completion(ToString(_specifier_)).
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. Perform HostImportModuleDynamically(_referencingScriptOrModule_, _specifierString_, _promiseCapability_).
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-placeholder-14"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-15"><h1></h1></emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-placeholder-16.1"><h1></h1></emu-clause>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-placeholder-16.2.1.1"><h1></h1></emu-clause>
      <emu-clause id="sec-placeholder-16.2.1.2"><h1></h1></emu-clause>
      <emu-clause id="sec-placeholder-16.2.1.3"><h1></h1></emu-clause>
      <emu-clause id="sec-placeholder-16.2.1.4"><h1></h1></emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>Cyclic Module Records</h1>
        <p>A <dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of Strings
              </td>
              <td>
                A List of all the |ModuleSpecifier| strings used by the module represented by this record to request the importation of a module. The List is source text occurrence ordered.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[LoadedRequestedModules]]</ins>
              </td>
              <td>
                <ins>a List of Record { [[Specifier]]: a String, [[Module]]: a Module Record }</ins>
              </td>
              <td>
                <ins>A map from the specifier strings used by the module represented by this record to request the importation of a module to the resolved Module Record. The list does not contain two different Records with the same [[Specifier]].</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluation]]
              </td>
              <td>
                a Boolean
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>
        <p>In addition to the methods defined in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> Cyclic Module Records have the additional methods listed in <emu-xref href="#table-cyclic-module-methods"></emu-xref></p>
        <emu-table id="table-cyclic-module-methods" caption="Additional Abstract Methods of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                <ins>LoadRequestedModules()</ins>
              </td>
              <td>
                <ins>Loads all the imported modules, and returns a promise resolved with *undefined* or rejected with the loading error.</ins>
              </td>
            </tr>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                ExecuteModule( [ _promiseCapability_ ] )
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            <ins>
              LoadRequestedModules ( ): a Promise object
            </ins>
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>It populates the [[LoadedRequestedModules]] of all the Modue Records in the dependency graph of _module_. (Most of the work is done by the auxiliary function InnerModuleLoading.)</dd>
          </dl>

          <emu-alg>
            1. Let _pc_ be ! NewPromiseCapability(%Promise%).
            1. Let _state_ be a new Record { [[IsLoading]]: *true*, [[PendingModules]]: 1, [[PromiseCapability]]: _pc_ }.
            1. Perform InnerModuleLoading(_state_, _module_, ~empty~, ~empty~).
            1. Return _pc_.[[Promise]].
          </emu-alg>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              <ins>
                InnerModuleLoading (
                  _state_: a Record { [[IsLoading]]: a Boolean&comma; [[PendingModules]]: an integer&comma; [[PromiseCapability]]: a PromiseCapability Record },
                  _module_: a Module Record,
                  _parent_: a Cyclic Module Record or ~empty~,
                  _specifier_: a String or ~empty~,
                ): ~unused~
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. If _state_.[[IsLoading]] is *false*, return.
              1. Assert: _state_.[[PendingModules]] &ge; 1.
              1. Set _state_.[[PendingModules]] to _state_.[[PendingModules]] - 1.
              1. If _module_ is a Cyclic Module Record and _module_.[[Status]] is ~unlinked~, then
                1. Let _newPendingModules_ be the length of _module_.[[RequestedModules]].
                1. Set _state_.[[PendingModules]] to _state_.[[PendingModules]] + _newPendingModules_.
                1. For each String _required_ of _module_.[[RequestedModules]], do
                  1. If there exists a Record _loaded_ in _module_.[[LoadedRequestedModules]] such that _loaded_.[[Specifier]] is _required_, then
                    1. Perform InnerModuleLoading(_state_, _loaded_.[[Module]], _module_, _required_).
                  1. Perform HostLoadImportedModule(_module_, _required_, _state_).
                1. Return.
              1. Assert: _parent_ is empty if and only if _specifier_ is empty.
              1. If _parent_ is not ~empty~, then
                1. If _parent_.[[LoadedRequestedModules]] contains a Record _record_ such that _record_.[[Specifier]] is _specifier_, then
                  1. Assert: _record_.[[Module]] is _requiredModule_.
                1. Else,
                  1. Add Record { [[Specifier]]: _specifier_, [[Module]]: _requiredModule_ } to _parent_.[[LoadedRequestedModules]].
              1. If _state_.[[PendingModules]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ModuleLoadingError" type="abstract operation">
            <h1>
              <ins>
                ModuleLoadingError (
                  _state_: a Record { [[IsLoading]]: a Boolean&comma; [[PendingModules]]: an integer&comma; [[PromiseCapability]]: a PromiseCapability Record },
                  _error_: an ECMAScript language value,
                ): ~unused~
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used to reject the promise returned by LoadRequestedModules ( ).</dd>
            </dl>

            <emu-alg>
              1. If _state_.[[IsLoading]] is *false*, return.
              1. Set _state_.[[IsLoading]] to *false*.
              1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, &laquo; _error_ &raquo;).
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-placeholder-16.2.1.6"><h1></h1></emu-clause>

      <emu-clause id="sec-hostresolveimportedmodule" type="host-defined abstract operation">
        <h1>
          HostResolveImportedModule (
            _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
            _specifier_: a |ModuleSpecifier| String,
          ): either a normal completion containing a Module Record or a throw completion
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It provides the concrete Module Record subclass instance that corresponds to _specifier_ occurring within the context of the script or module represented by _referencingScriptOrModule_. _referencingScriptOrModule_ may be *null* if the resolution is being performed in the context of an <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression and there is no active script or module at that time.</dd>
        </dl>

        <emu-note>
          <p>An example of when _referencingScriptOrModule_ can be *null* is in a web browser host. There, if a user clicks on a control given by</p>

          <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

          <p>there will be no active script or module at the time the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression runs. More generally, this can happen in any situation where the host pushes execution contexts with *null* ScriptOrModule components onto the execution context stack.</p>
        </emu-note>

        <p>An implementation of HostResolveImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            If the returned Completion Record is a normal completion, it must be a normal completion containing an instance of a concrete subclass of Module Record.
          </li>
          <li>
            If a Module Record corresponding to the pair _referencingScriptOrModule_, _specifier_ does not exist or cannot be created, an exception must be thrown.
          </li>
          <li>
            Each time this operation is called with a specific _referencingScriptOrModule_, _specifier_ pair as arguments it must return the same Module Record instance if it completes normally.
          </li>
        </ul>
        <p>Multiple different _referencingScriptOrModule_, _specifier_ pairs may map to the same Module Record instance. The actual mapping semantic is host-defined but typically a normalization process is applied to _specifier_ as part of the mapping process. A typical normalization process would include actions such as alphabetic case folding and expansion of relative and abbreviated path specifiers.</p>
      </emu-clause>

      <emu-clause id="sec-hostimportmoduledynamically" type="host-defined abstract operation">
        <h1>
          HostImportModuleDynamically (
            _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
            _specifier_: a |ModuleSpecifier| String,
            _promiseCapability_: a PromiseCapability Record,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It performs any necessary setup work in order to make available the module corresponding to _specifier_ occurring within the context of the script or module represented by _referencingScriptOrModule_. _referencingScriptOrModule_ may be *null* if there is no active script or module when the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression occurs. It then performs FinishDynamicImport to finish the dynamic import process.</dd>
        </dl>
        <p>An implementation of HostImportModuleDynamically must conform to the following requirements:</p>

        <ul>
          <li>
            It must return ~unused~. Success or failure must instead be signaled as discussed below.
          </li>
          <li>
            The host environment must conform to one of the two following sets of requirements:
            <dl>
              <dt>Success path</dt>

              <dd>
                <ul>
                  <li>At some future time, the host environment must perform FinishDynamicImport(_referencingScriptOrModule_, _specifier_, _promiseCapability_, _promise_), where _promise_ is a Promise resolved with *undefined*.</li>

                  <li>Any subsequent call to HostResolveImportedModule after FinishDynamicImport has completed, given the arguments _referencingScriptOrModule_ and _specifier_, must return a normal completion containing a module which has already been evaluated, i.e. whose Evaluate concrete method has already been called and returned a normal completion.</li>
                </ul>
              </dd>

              <dt>Failure path</dt>

              <dd>
                <ul>
                  <li>At some future time, the host environment must perform FinishDynamicImport(_referencingScriptOrModule_, _specifier_, _promiseCapability_, _promise_), where _promise_ is a Promise rejected with an error representing the cause of failure.</li>
                </ul>
              </dd>
            </dl>
          </li>
          <li>
            If the host environment takes the success path once for a given _referencingScriptOrModule_, _specifier_ pair, it must always do so for subsequent calls.
          </li>
          <li>
            The operation must not call _promiseCapability_.[[Resolve]] or _promiseCapability_.[[Reject]], but instead must treat _promiseCapability_ as an opaque identifying value to be passed through to FinishDynamicImport.
          </li>
        </ul>

        <p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to allow HostResolveImportedModule to synchronously retrieve the appropriate Module Record, and then calling its Evaluate concrete method. This might require performing similar normalization as HostResolveImportedModule does.</p>
      </emu-clause>

      <emu-clause id="sec-finishdynamicimport" type="abstract operation">
        <h1>
          FinishDynamicImport (
            _referencingScriptOrModule_: unknown,
            _specifier_: unknown,
            _promiseCapability_: a PromiseCapability Record,
            _innerPromise_: unknown,
          ): ~unused~
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>FinishDynamicImport completes the process of a dynamic import originally started by an <emu-xref href="#sec-import-calls">`import()`</emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to _innerPromise_'s resolution. It is performed by host environments as part of HostImportModuleDynamically.</dd>
        </dl>
        <emu-alg>
          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_result_) that captures _referencingScriptOrModule_, _specifier_, and _promiseCapability_ and performs the following steps when called:
            1. Assert: _result_ is *undefined*.
            1. Let _moduleRecord_ be ! HostResolveImportedModule(_referencingScriptOrModule_, _specifier_).
            1. Assert: Evaluate has already been invoked on _moduleRecord_ and successfully completed.
            1. Let _namespace_ be Completion(GetModuleNamespace(_moduleRecord_)).
            1. If _namespace_ is an abrupt completion, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _namespace_.[[Value]] &raquo;).
            1. Else,
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _namespace_.[[Value]] &raquo;).
            1. Return ~unused~.
          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, &laquo; &raquo;).
          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_error_) that captures _promiseCapability_ and performs the following steps when called:
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _error_ &raquo;).
            1. Return ~unused~.
          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 0, *""*, &laquo; &raquo;).
          1. Perform PerformPromiseThen(_innerPromise_, _onFulfilled_, _onRejected_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-HostLoadImportedModule" type="host-defined abstract operation">
        <h1>
          <ins>
            HostLoadImportedModule (
              _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
              _specifier_: a String,
              _payload_: a Record,
            ): ~unused~
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <p>An implementation of HostLoadImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            At some future time, the host environment must perform FinishLoadImportedModule(_referencingScriptOrModule_, _specifier_, _payload_, _result_), where _result_ is either a normal completion containing the loaded Module Record or a throw completion.
          </li>
          <li>
            If this operation is called multiple times with the same (_referencingScriptOrModule_, _specifier_) pair and it performs FinishLoadImportedModule(_referencingScriptOrModule_, _specifier_, _payload_, _result_) where _result_ is a normal completion, then it must perform FinishLoadImportedModule(_referencingScriptOrModule_, _specifier_, _payload_, _result_) with the same _result_ each time.
          </li>
          <li>
            The operation must treat _payload_ as an opaque value to be passed through to FinishLoadImportedModule.
          </li>
        </ul>

        <p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to the appropriate Module Record. Multiple different _referencingScriptOrModule_, _specifier_ pairs may map to the same Module Record instance. The actual mapping semantic is host-defined but typically a normalization process is applied to _specifier_ as part of the mapping process. A typical normalization process would include actions such as alphabetic case folding and expansion of relative and abbreviated path specifiers.</p>

        <p>The default implementation of HostLoadImportedModule performs the following steps when called:</p>
        <emu-alg>
          1. Let _result_ be Completion(HostResolveImportedModule(_referencingScriptOrModule_, _specifier_)).
          1. Perform FinishLoadImportedModule(_referencingScriptOrModule_, _specifier_, _payload_, _result_).
        </emu-alg>
        <p>ECMAScript hosts must implement either HostLoadImportedModule or HostResolveImportedModule.</p>
      </emu-clause>

      <emu-clause id="sec-FinishLoadImportedModule" type="abstract operation">
        <h1>
          <ins>
            FinishLoadImportedModule (
              _referencingModule_: a Module Record,
              _specifier_: a String,
              _payload_: a Record,
              _result_: either a normal completion containing a Module Record or a throw completion,
            ): ~unused~
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. If _result_ is a normal completion, then
            1. Perform InnerModuleLoading(_payload_, _result_.[[Value]], _referencingModule_, _specifier_).
          1. Else,
            1. Perform ModuleLoadingError(_payload_, _result_.[[Value]]).
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
