<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Modules Host Hooks Refactor
stage: -1
contributors: Nicol√≤ Ribaudo
</pre>

<!--
Idea adapted from @ljharb, but avoiding multiple equal ids.
https://github.com/rricard/proposal-symbol-predicates/blob/7c8c661604d89c3af7a83461d3631bf810fa3487/spec.emu#L13-L24
-->
<style>
[id^="sec-placeholder"], [href^="#sec-placeholder"] {
  display: none;
}
</style>
<script>
  Array.from(document.querySelectorAll('ol.toc li'), function (node) {
    if (node.querySelector(':scope > [href^="#sec-placeholder"]')) {
      node.style.display = 'none';
    }
  });
</script>

<emu-clause id="sec-placeholder-1"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-2"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-3"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-4"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-5"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-6"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-7"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-8"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-9"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-10"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-11"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-12"><h1></h1></emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-placeholder-13.1"><h1></h1></emu-clause>
  <emu-clause id="sec-placeholder-13.2"><h1></h1></emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>Left-Hand-Side Expressions</h1>

    <emu-clause id="sec-placeholder-13.3.1"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.2"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.3"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.4"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.5"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.6"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.7"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.8"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.9"><h1></h1></emu-clause>

    <emu-clause id="sec-import-calls">
      <h1>Import Calls</h1>

      <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `)`</emu-grammar>
        <emu-alg>
          1. Let _referencingScriptOrModule_ be GetActiveScriptOrModule().
          1. Let _argRef_ be the result of evaluating |AssignmentExpression|.
          1. Let _specifier_ be ? GetValue(_argRef_).
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _specifierString_ be Completion(ToString(_specifier_)).
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. <del>Perform HostImportModuleDynamically(_referencingScriptOrModule_, _specifierString_, _promiseCapability_).</del>
          1. <ins>Let _state_ be a new Record { [[Action]]: ~dynamic-import~, [[PromiseCapability]]: _promiseCapability_ }.</ins>
          1. <ins>If _referencingScriptOrModule_ is not *null* and there exists a Record _record_ in _referencingScriptOrModule_.[[LoadedModules]] such that _record_.[[Specifier]] is _specifierString_, then</ins>
            1. <ins>Perform ContinueDynamicImport(_state_, _record_.[[Module]], _referencingScriptOrModule_, _specifierString_).</ins>
          1. <ins>Else,</ins>
            1. <ins>Perform HostLoadImportedModule(_referencingScriptOrModule_, _specifierString_, _state_).</ins>
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-placeholder-14"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-15"><h1></h1></emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-scripts">
    <h1>Scripts</h1>

    <emu-clause id="sec-placeholder-16.1.1"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-16.1.2"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-16.1.3"><h1></h1></emu-clause>

    <emu-clause id="sec-script-records">
      <h1>Script Records</h1>

      <p>A <dfn id="script-record" variants="Script Records">Script Record</dfn> encapsulates information about a script being evaluated. Each script record contains the fields listed in <emu-xref href="#table-script-records"></emu-xref>.</p>

      <emu-table id="table-script-records" caption="Script Record Fields">
        <table>
          <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Realm]]
            </td>
            <td>
              a Realm Record or *undefined*
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              [[ECMAScriptCode]]
            </td>
            <td>
              a Parse Node
            </td>
            <td></td>
          </tr>
            <tr>
              <td>
                <ins>[[LoadedModules]]</ins>
              </td>
              <td>
                <ins>a List of Record { [[Specifier]]: a String, [[Module]]: a Module Record }</ins>
              </td>
              <td>
                <ins>A map from the specifier strings imported by this script to the resolved Module Record. The list does not contain two different Records with the same [[Specifier]].</ins>
              </td>
            </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              anything (default value is ~empty~)
            </td>
            <td></td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-parse-script" type="abstract operation">
      <h1>
        ParseScript (
          _sourceText_: ECMAScript source text,
          _realm_: unknown,
          _hostDefined_: unknown,
        ): a Script Record or a non-empty List of *SyntaxError* objects
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Script Record based upon the result of parsing _sourceText_ as a |Script|.</dd>
      </dl>

      <emu-alg>
        1. Let _script_ be ParseText(_sourceText_, |Script|).
        1. If _script_ is a List of errors, return _script_.
        1. Return Script Record { [[Realm]]: _realm_, [[ECMAScriptCode]]: _script_, <ins>[[LoadedModules]]: a new empty List,</ins> [[HostDefined]]: _hostDefined_ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-placeholder-16.2.1.1"><h1></h1></emu-clause>
      <emu-clause id="sec-placeholder-16.2.1.2"><h1></h1></emu-clause>
      <emu-clause id="sec-placeholder-16.2.1.3"><h1></h1></emu-clause>
      <emu-clause id="sec-placeholder-16.2.1.4"><h1></h1></emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>Cyclic Module Records</h1>
        <p>A <dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of Strings
              </td>
              <td>
                A List of all the |ModuleSpecifier| strings used by the module represented by this record to request the importation of a module. The List is source text occurrence ordered.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[LoadedModules]]</ins>
              </td>
              <td>
                <ins>a List of Record { [[Specifier]]: a String, [[Module]]: a Module Record }</ins>
              </td>
              <td>
                <ins>A map from the specifier strings used by the module represented by this record to request the importation of a module to the resolved Module Record. The list does not contain two different Records with the same [[Specifier]].</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluation]]
              </td>
              <td>
                a Boolean
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>
        <p>In addition to the methods defined in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> Cyclic Module Records have the additional methods listed in <emu-xref href="#table-cyclic-module-methods"></emu-xref></p>
        <emu-table id="table-cyclic-module-methods" caption="Additional Abstract Methods of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                <ins>LoadRequestedModules()</ins>
              </td>
              <td>
                <ins>Loads all the imported modules, and returns a promise resolved with *undefined* or rejected with the loading error.</ins>
              </td>
            </tr>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                ExecuteModule( [ _promiseCapability_ ] )
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            <ins>
              LoadRequestedModules ( ): a Promise object
            </ins>
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>It populates the [[LoadedModules]] of all the Modue Records in the dependency graph of _module_. (Most of the work is done by the auxiliary function InnerModuleLoading.)</dd>
          </dl>

          <emu-alg>
            1. Let _pc_ be ! NewPromiseCapability(%Promise%).
            1. Let _state_ be a new Record { [[Action]]: ~graph-loading~, [[IsLoading]]: *true*, [[PendingModules]]: 0, [[PromiseCapability]]: _pc_ }.
            1. Perform InnerModuleLoading(_state_, _module_).
            1. Return _pc_.[[Promise]].
          </emu-alg>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              <ins>
                InnerModuleLoading (
                  _state_: a Record { [[Action]]: ~graph-loading~&comma; [[IsLoading]]: a Boolean&comma; [[PendingModules]]: an integer&comma; [[PromiseCapability]]: a PromiseCapability Record },
                  _module_: a Module Record,
                ): ~unused~
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. Assert: _state_.[[IsLoading]] is *true*.
              1. If _module_ is a Cyclic Module Record and _module_.[[Status]] is ~unlinked~, then
                1. For each String _required_ of _module_.[[RequestedModules]], do
                  1. If there exists a Record _loaded_ in _module_.[[LoadedModules]] such that _loaded_.[[Specifier]] is _required_, then
                    1. Perform InnerModuleLoading(_state_, _loaded_.[[Module]]).
                  1. Set _state_.[[PendingModules]] to _state_.[[PendingModules]] + 1.
                  1. Perform HostLoadImportedModule(_module_, _required_, _state_).
              1. If _state_.[[PendingModules]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
            <h1>
              <ins>
                ContinueModuleLoading (
                  _state_: a Record { [[Action]]: ~graph-loading~&comma; [[IsLoading]]: a Boolean&comma; [[PendingModules]]: an integer&comma; [[PromiseCapability]]: a PromiseCapability Record },
                  _result_: either a normal completion containing a Module Record or a throw completion,
                ): ~unused~
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used to re-enter the loading process after a call to the HostLoadImportedModule host hook.</dd>
            </dl>

            <emu-alg>
              1. If _state_.[[IsLoading]] is *false*, return.
              1. If _result_ is a normal completion, then
                1. Assert: _state_.[[PendingModules]] &ge; 1.
                1. Set _state_.[[PendingModules]] to _state_.[[PendingModules]] - 1.
                1. Perform InnerModuleLoading(_state_, _result_.[[Value]]).
              1. Else,
                1. Set _state_.[[IsLoading]] to *false*.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, &laquo; _result_.[[Value]] &raquo;).
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-placeholder-16.2.1.6"><h1></h1></emu-clause>

      <emu-clause id="sec-ResolveImportedModule" type="abstract operation">
        <h1>
          <ins>
            ResolveImportedModule (
              _referencingModule_: a Cyclic Module Record,
              _specifier_: a |ModuleSpecifier| String,
            ): either a normal completion containing a Module Record or a throw completion
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. If _referencingModule_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is _specifier_, then
            1. Return NormalCompletion(_record_.[[Module]]).
          1. Else, throw a *TypeError* exception.
        </emu-alg>

        <emu-note type="editor">
          Replace every occurrence of HostResolveImportedModule with ResolveImportedModule, except for the invocation in HostLoadImportedModule.
        </emu-note>
      </emu-clause>

      <emu-clause id="sec-HostLoadImportedModule" type="host-defined abstract operation">
        <h1>
          <ins>
            HostLoadImportedModule (
              _referencingScriptOrModule_: a Script Record, a Cyclic Module Record, or *null*,
              _specifier_: a String,
              _payload_: a Record with an [[Action]] field whose value is ~graph-loading~ or ~dynamic-import~,
            ): ~unused~
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <p>An implementation of HostLoadImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            The host environment must perform FinishLoadImportedModule(_referencingScriptOrModule_, _specifier_, _payload_, _result_), where _result_ is either a normal completion containing the loaded Module Record or a throw completion, either synchronously or asynchronously.
          </li>
          <li>
            If this operation is called multiple times with the same (_referencingScriptOrModule_, _specifier_) pair and it performs FinishLoadImportedModule(_referencingScriptOrModule_, _specifier_, _payload_, _result_) where _result_ is a normal completion, then it must perform FinishLoadImportedModule(_referencingScriptOrModule_, _specifier_, _payload_, _result_) with the same _result_ each time.
          </li>
          <li>
            The operation must treat _payload_ as an opaque value to be passed through to FinishLoadImportedModule.
          </li>
        </ul>

        <p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to the appropriate Module Record. Multiple different _referencingScriptOrModule_, _specifier_ pairs may map to the same Module Record instance. The actual mapping semantic is host-defined but typically a normalization process is applied to _specifier_ as part of the mapping process. A typical normalization process would include actions such as alphabetic case folding and expansion of relative and abbreviated path specifiers.</p>

        <p>The default implementation of HostLoadImportedModule performs the following steps when called:</p>
        <emu-alg>
          1. If _payload_.[[Action]] is ~graph-loading~, then
            1. Let _result_ be Completion(HostResolveImportedModule(_referencingScriptOrModule_, _specifier_)).
            1. Perform FinishLoadImportedModule(_referencingScriptOrModule_, _specifier_, _payload_, _result_).
          1. Else,
            1. Perform HostImportModuleDynamically(_referencingScriptOrModule_, _specifier_, _payload_.[[PromiseCapability]]).
        </emu-alg>

        <p>ECMAScript hosts must implement either HostLoadImportedModule or HostResolveImportedModule and HostImportModuleDynamically.</p>

        <emu-note type="editor">
          The HostResolveImportedModule and HostImportModuleDynamically host hooks, and the FinishDynamicImport abstract operation, have not been deleted for temporary backward compatibility with host specifications. They will be removed in the future, as well as the default implementation of HostLoadImportedModule.
        </emu-note>

        <emu-clause id="sec-hostresolveimportedmodule" type="host-defined abstract operation">
          <h1>
            HostResolveImportedModule (
              _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
              _specifier_: a |ModuleSpecifier| String,
            ): either a normal completion containing a Module Record or a throw completion
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It provides the concrete Module Record subclass instance that corresponds to _specifier_ occurring within the context of the script or module represented by _referencingScriptOrModule_. _referencingScriptOrModule_ may be *null* if the resolution is being performed in the context of an <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression and there is no active script or module at that time.</dd>
          </dl>

          <emu-note>
            <p>An example of when _referencingScriptOrModule_ can be *null* is in a web browser host. There, if a user clicks on a control given by</p>

            <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

            <p>there will be no active script or module at the time the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression runs. More generally, this can happen in any situation where the host pushes execution contexts with *null* ScriptOrModule components onto the execution context stack.</p>
          </emu-note>

          <p>An implementation of HostResolveImportedModule must conform to the following requirements:</p>
          <ul>
            <li>
              If the returned Completion Record is a normal completion, it must be a normal completion containing an instance of a concrete subclass of Module Record.
            </li>
            <li>
              If a Module Record corresponding to the pair _referencingScriptOrModule_, _specifier_ does not exist or cannot be created, an exception must be thrown.
            </li>
            <li>
              Each time this operation is called with a specific _referencingScriptOrModule_, _specifier_ pair as arguments it must return the same Module Record instance if it completes normally.
            </li>
          </ul>
          <p>Multiple different _referencingScriptOrModule_, _specifier_ pairs may map to the same Module Record instance. The actual mapping semantic is host-defined but typically a normalization process is applied to _specifier_ as part of the mapping process. A typical normalization process would include actions such as alphabetic case folding and expansion of relative and abbreviated path specifiers.</p>
        </emu-clause>

        <emu-clause id="sec-hostimportmoduledynamically" type="host-defined abstract operation">
          <h1>
            HostImportModuleDynamically (
              _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
              _specifier_: a |ModuleSpecifier| String,
              _promiseCapability_: a PromiseCapability Record,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It performs any necessary setup work in order to make available the module corresponding to _specifier_ occurring within the context of the script or module represented by _referencingScriptOrModule_. _referencingScriptOrModule_ may be *null* if there is no active script or module when the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression occurs. It then performs FinishDynamicImport to finish the dynamic import process.</dd>
          </dl>
          <p>An implementation of HostImportModuleDynamically must conform to the following requirements:</p>

          <ul>
            <li>
              It must return ~unused~. Success or failure must instead be signaled as discussed below.
            </li>
            <li>
              The host environment must conform to one of the two following sets of requirements:
              <dl>
                <dt>Success path</dt>

                <dd>
                  <ul>
                    <li>At some future time, the host environment must perform FinishDynamicImport(_referencingScriptOrModule_, _specifier_, _promiseCapability_, _promise_), where _promise_ is a Promise resolved with *undefined*.</li>

                    <li>Any subsequent call to HostResolveImportedModule after FinishDynamicImport has completed, given the arguments _referencingScriptOrModule_ and _specifier_, must return a normal completion containing a module which has already been evaluated, i.e. whose Evaluate concrete method has already been called and returned a normal completion.</li>
                  </ul>
                </dd>

                <dt>Failure path</dt>

                <dd>
                  <ul>
                    <li>At some future time, the host environment must perform FinishDynamicImport(_referencingScriptOrModule_, _specifier_, _promiseCapability_, _promise_), where _promise_ is a Promise rejected with an error representing the cause of failure.</li>
                  </ul>
                </dd>
              </dl>
            </li>
            <li>
              If the host environment takes the success path once for a given _referencingScriptOrModule_, _specifier_ pair, it must always do so for subsequent calls.
            </li>
            <li>
              The operation must not call _promiseCapability_.[[Resolve]] or _promiseCapability_.[[Reject]], but instead must treat _promiseCapability_ as an opaque identifying value to be passed through to FinishDynamicImport.
            </li>
          </ul>

          <p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to allow HostResolveImportedModule to synchronously retrieve the appropriate Module Record, and then calling its Evaluate concrete method. This might require performing similar normalization as HostResolveImportedModule does.</p>
        </emu-clause>

        <emu-clause id="sec-finishdynamicimport" type="abstract operation">
          <h1>
            FinishDynamicImport (
              _referencingScriptOrModule_: unknown,
              _specifier_: unknown,
              _promiseCapability_: a PromiseCapability Record,
              _innerPromise_: unknown,
            ): ~unused~
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>FinishDynamicImport completes the process of a dynamic import originally started by an <emu-xref href="#sec-import-calls">`import()`</emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to _innerPromise_'s resolution. It is performed by host environments as part of HostImportModuleDynamically.</dd>
          </dl>
          <emu-alg>
            1. <ins>Let _state_ be a new Record { [[Action]]: ~dynamic-import~, [[PromiseCapability]]: _promiseCapability_ }.</ins>
            1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_result_) that captures _referencingScriptOrModule_, _specifier_, and <del>_promiseCapability_</del><ins>_state_</ins> and performs the following steps when called:
              1. Assert: _result_ is *undefined*.
              1. Let _moduleRecord_ be ! HostResolveImportedModule(_referencingScriptOrModule_, _specifier_).
              1. <ins>Perform ContinueDynamicImport(_state_, NormalCompletion(_moduleRecord_), _referencingScriptOrModule_, _specifier_).</ins>
              1. <del>Assert: Evaluate has already been invoked on _moduleRecord_ and successfully completed.</del>
              1. <del>Let _namespace_ be Completion(GetModuleNamespace(_moduleRecord_)).</del>
              1. <del>If _namespace_ is an abrupt completion, then</del>
                1. <del>Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _namespace_.[[Value]] &raquo;).</del>
              1. <del>Else,</del>
                1. <del>Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _namespace_.[[Value]] &raquo;).</del>
              1. Return ~unused~.
            1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, &laquo; &raquo;).
            1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_error_) that captures <del>_promiseCapability_</del><ins>_referencingScriptOrModule_, _specifier_, and _state_</ins> and performs the following steps when called:
              1. <del>Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _error_ &raquo;).</del>
              1. <ins>Perform ContinueDynamicImport(_state_, ThrowCompletion(_error_), _referencingScriptOrModule_, _specifier_).</ins>
              1. Return ~unused~.
            1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 0, *""*, &laquo; &raquo;).
            1. Perform PerformPromiseThen(_innerPromise_, _onFulfilled_, _onRejected_).
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-FinishLoadImportedModule" type="abstract operation">
        <h1>
          <ins>
            FinishLoadImportedModule (
              _referencingScriptOrModule_: a Script Record, a Cyclic Module Record or *null*,
              _specifier_: a String,
              _payload_: a Record with an [[Action]] field whose value is ~graph-loading~ or ~dynamic-import~,
              _result_: either a normal completion containing a Module Record or a throw completion,
            ): ~unused~
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>
        <emu-alg>
          1. If _referencingScriptOrModule_ is not *null* and _result_ is a normal completion, then
            1. If _referencingScriptOrModule_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is _specifier_, then
              1. Assert: _record_.[[Module]] is _result_.[[Value]].
            1. Else, add Record { [[Specifier]]: _specifier_, [[Module]]: _result_.[[Value]] } to _referencingScriptOrModule_.[[LoadedModules]].
          1. If _payload_.[[Action]] is ~graph-loading~, then
            1. Assert: _referencingScriptOrModule_ is a Cyclic Module Record.
            1. Perform ContinueModuleLoading(_payload_, _result_).
          1. Else,
            1. Perform ContinueDynamicImport(_payload_, _result_).
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
        <h1>
          <ins>
            ContinueDynamicImport (
              _state_: a Record { [[Action]]: ~dynamic-import~&comma; [[PromiseCapability]]: a PromiseCapability Record },
              _module_: either a normal completion containing a Module Record or a throw completion,
            ): ~unused~
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>ContinueDynamicImport completes the process of a dynamic import originally started by an <emu-xref href="#sec-import-calls">`import()`</emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to _innerPromise_'s resolution.</dd>
        </dl>
        <emu-alg>
          1. Let _promiseCapability_ be _state_.[[PromiseCapability]].
          1. IfAbruptRejectPromise(_module_, _promiseCapability_).
          1. If _module_ is a Cyclic Module Record, then
            1. Let _load_ be Completion(Await(_module_.LoadRequestedModules())).
            1. IfAbruptRejectPromise(_load_, _promiseCapability_).
          1. Let _link_ be Completion(_module_.Link()).
          1. IfAbruptRejectPromise(_link_, _promiseCapability_).
          1. Let _evaluate_ be Completion(Await(_module_.Evaluate())).
          1. IfAbruptRejectPromise(_evaluate_, _promiseCapability_).
          1. Let _namespace_ be Completion(GetModuleNamespace(_module_)).
          1. IfAbruptRejectPromise(_namespace_, _state_.[[PromiseCapability]]).
          1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _namespace_ &raquo;).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
