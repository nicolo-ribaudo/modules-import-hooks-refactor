<!doctype html>
<meta charset="utf8">
<link rel="stylesheet" href="./spec.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/8.4/styles/github.min.css">
<script src="./spec.js"></script>
<pre class="metadata">
title: Modules Host Hooks Refactor
stage: -1
contributors: Nicol√≤ Ribaudo
location: https://nicolo-ribaudo.github.io/modules-import-hooks-refactor/
</pre>

<!--
Idea adapted from @ljharb, but avoiding multiple equal ids.
https://github.com/rricard/proposal-symbol-predicates/blob/7c8c661604d89c3af7a83461d3631bf810fa3487/spec.emu#L13-L24
-->
<style>
[id^="sec-placeholder"], [href^="#sec-placeholder"] {
  display: none;
}
</style>
<script>
  Array.from(document.querySelectorAll('ol.toc li'), function (node) {
    if (node.querySelector(':scope > [href^="#sec-placeholder"]')) {
      node.style.display = 'none';
    }
  });
</script>

<emu-clause id="sec-placeholder-1"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-2"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-3"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-4"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-5"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-6"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-7"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-8"><h1></h1></emu-clause>

<emu-clause id="sec-executable-code-and-execution-contexts">
  <h1>Executable Code and Execution Contexts</h1>

  <emu-clause id="sec-placeholder-9.1"><h1></h1></emu-clause>
  <emu-clause id="sec-placeholder-9.2"><h1></h1></emu-clause>

  <emu-clause id="sec-code-realms">
    <h1>Realms</h1>
    <p>Before it is evaluated, all ECMAScript code must be associated with a <dfn id="realm" variants="realms">realm</dfn>. Conceptually, a realm consists of a set of intrinsic objects, an ECMAScript global environment, all of the ECMAScript code that is loaded within the scope of that global environment, and other associated state and resources.</p>
    <p>A realm is represented in this specification as a <dfn id="realm-record" variants="Realm Records">Realm Record</dfn> with the fields specified in <emu-xref href="#table-realm-record-fields"></emu-xref>:</p>
    <emu-table id="table-realm-record-fields" caption="Realm Record Fields" oldids="table-21">
      <table>
        <tr>
          <th>
            Field Name
          </th>
          <th>
            Value
          </th>
          <th>
            Meaning
          </th>
        </tr>
        <tr>
          <td>
            [[Intrinsics]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            [[GlobalObject]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            [[GlobalEnv]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            [[TemplateMap]]
          </td>
          <td></td>
          <td></td>
        </tr>
        <tr>
          <td>
            <ins>[[LoadedModules]]</ins>
          </td>
          <td>
            <ins>a List of Records { [[Specifier]]: a String, [[Module]]: a Module Record }</ins>
          </td>
          <td>
            <ins>A map from the specifier strings imported by this realm to the resolved Module Record. The list does not contain two different Records with the same [[Specifier]].</ins>
          </td>
        </tr>
        <tr>
          <td>
            <ins>[[LoadingModules]]</ins>
          </td>
          <td>
            <ins>a List of Records { [[Specifier]]: a String, [[LoadStates]]: a List of ModuleLoadState Records }</ins>
          </td>
          <td>
            <ins>A map from the specifier strings imported by this realm to the loading processes that are waiting for the resolved module record. It is used to avoid multiple calls to HostLoadImportedModule with the same (_specifier_, _referrer_) pair. The list does not contain two different Records with the same [[Specifier]].</ins>

            <emu-note>
              <ins>As mentioned in HostLoadImportedModule, [[LoadedModules]] and [[LoadingModules]] in Realm Records are only used when running an `import()` expression in a context where there is no active script or module.</ins>
            </emu-note>
          </td>
        </tr>
        <tr>
          <td>
            [[HostDefined]]
          </td>
          <td></td>
          <td></td>
        </tr>
      </table>
    </emu-table>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-placeholder-10"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-11"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-12"><h1></h1></emu-clause>

<emu-clause id="sec-ecmascript-language-expressions">
  <h1>ECMAScript Language: Expressions</h1>

  <emu-clause id="sec-placeholder-13.1"><h1></h1></emu-clause>
  <emu-clause id="sec-placeholder-13.2"><h1></h1></emu-clause>

  <emu-clause id="sec-left-hand-side-expressions">
    <h1>Left-Hand-Side Expressions</h1>

    <emu-clause id="sec-placeholder-13.3.1"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.2"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.3"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.4"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.5"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.6"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.7"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.8"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-13.3.9"><h1></h1></emu-clause>

    <emu-clause id="sec-import-calls">
      <h1>Import Calls</h1>

      <emu-clause id="sec-import-call-runtime-semantics-evaluation" type="sdo">
        <h1>Runtime Semantics: Evaluation</h1>

        <emu-grammar>ImportCall : `import` `(` AssignmentExpression `)`</emu-grammar>
        <emu-alg>
          1. Let <del>_referencingScriptOrModule_</del><ins>_referrer_</ins> be GetActiveScriptOrModule().
          1. <ins>If _referrer_ is *null*, set _referrer_ to the current Realm Record.</ins>
          1. Let _argRef_ be the result of evaluating |AssignmentExpression|.
          1. Let _specifier_ be ? GetValue(_argRef_).
          1. Let _promiseCapability_ be ! NewPromiseCapability(%Promise%).
          1. Let _specifierString_ be Completion(ToString(_specifier_)).
          1. IfAbruptRejectPromise(_specifierString_, _promiseCapability_).
          1. <del>Perform HostImportModuleDynamically(_referencingScriptOrModule_, _specifierString_, _promiseCapability_).</del>
          1. <ins>Let _state_ be a new ModuleLoadState Record { [[Action]]: ~dynamic-import~, [[PromiseCapability]]: _promiseCapability_ }.</ins>
          1. <ins>Perform LoadImportedModule(_referrer_, _specifierString_, _state_).</ins>
          1. <ins>NOTE: LoadImportedModule will call ContinueDynamicImport.</ins>
          1. Return _promiseCapability_.[[Promise]].
        </emu-alg>

        <emu-clause id="sec-ContinueDynamicImport" type="abstract operation">
          <h1>
            <ins>
              ContinueDynamicImport (
                _state_: a ModuleLoadState Record whose [[Action]] is ~dynamic-import~,
                _module_: either a normal completion containing a Module Record or a throw completion,
              ): ~unused~
            </ins>
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>ContinueDynamicImport completes the process of a dynamic import originally started by an <emu-xref href="#sec-import-calls">`import()`</emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to _innerPromise_'s resolution.</dd>
          </dl>
          <emu-alg>
            1. Let _promiseCapability_ be _state_.[[PromiseCapability]].
            1. If _module_ is an abrupt completion, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _module_.[[Value]] &raquo;).
              1. Return ~unused~.
            1. Else,
              1. Set _module_ to _module_.[[Value]].
            1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_reason_) that captures _promiseCapability_ and performs the following steps when called:
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _reason_ &raquo;).
              1. Return ~unused~.
            1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 1, &laquo; &raquo;).
            1. Let _linkAndEvaluateClosure_ be a new Abstract Closure with no parameters that captures _module_, _promiseCapability_, and _onRejected_ and performs the following steps when called:
              1. Let _link_ be Completion(_module_.Link()).
              1. If _link_ is an abrupt completion, then
                1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _link_.[[Value]] &raquo;).
                1. Return ~unused~.
              1. Let _evaluatePromise_ be _module_.Evaluate().
              1. Let _fulfilledClosure_ be a new Abstract Closure with no parameters that captures _module_ and _promiseCapability_ and performs the following steps when called:
                1. Let _namespace_ be Completion(GetModuleNamespace(_module_)).
                1. If _namespace_ is an abrupt completion, then
                  1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _namespace_.[[Value]] &raquo;).
                1. Else,
                  1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _namespace_.[[Value]] &raquo;).
                1. Return ~unused~.
              1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, &laquo; &raquo;).
              1. Perform PerformPromiseThen(_evaluatePromise_, _onFulfilled_, _onRejected_).
            1. Let _linkAndEvaluate_ be CreateBuiltinFunction(_linkAndEvaluateClosure_, 0, &laquo; &raquo;).
            1. If _module_ is a Cyclic Module Record, then
              1. Let _loadPromise_ be _module_.LoadRequestedModules().
              1. Perform PerformPromiseThen(_loadPromise_, _linkAndEvaluate_, _onRejected_).
            1. Else,
              1. Perform _linkAndEvaluateClosure_().
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>

<emu-clause id="sec-placeholder-14"><h1></h1></emu-clause>
<emu-clause id="sec-placeholder-15"><h1></h1></emu-clause>

<emu-clause id="sec-ecmascript-language-scripts-and-modules">
  <h1>ECMAScript Language: Scripts and Modules</h1>

  <emu-clause id="sec-scripts">
    <h1>Scripts</h1>

    <emu-clause id="sec-placeholder-16.1.1"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-16.1.2"><h1></h1></emu-clause>
    <emu-clause id="sec-placeholder-16.1.3"><h1></h1></emu-clause>

    <emu-clause id="sec-script-records">
      <h1>Script Records</h1>

      <p>A <dfn id="script-record" variants="Script Records">Script Record</dfn> encapsulates information about a script being evaluated. Each script record contains the fields listed in <emu-xref href="#table-script-records"></emu-xref>.</p>

      <emu-table id="table-script-records" caption="Script Record Fields">
        <table>
          <thead>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
          </thead>
          <tr>
            <td>
              [[Realm]]
            </td>
            <td>
              a Realm Record or *undefined*
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              [[ECMAScriptCode]]
            </td>
            <td>
              a Parse Node
            </td>
            <td></td>
          </tr>
          <tr>
            <td>
              <ins>[[LoadedModules]]</ins>
            </td>
            <td>
              <ins>a List of Records { [[Specifier]]: a String, [[Module]]: a Module Record }</ins>
            </td>
            <td>
              <ins>A map from the specifier strings imported by this script to the resolved Module Record. The list does not contain two different Records with the same [[Specifier]].</ins>
            </td>
          </tr>
          <tr>
            <td>
              <ins>[[LoadingModules]]</ins>
            </td>
            <td>
              <ins>a List of Records { [[Specifier]]: a String, [[LoadStates]]: a List of ModuleLoadState Records }</ins>
            </td>
            <td>
              <ins>A map from the specifier strings imported by this script to the loading processes that are waiting for the resolved module record. It is used to avoid multiple calls to HostLoadImportedModule with the same (_specifier_, _referrer_) pair. The list does not contain two different Records with the same [[Specifier]].</ins>
            </td>
          </tr>
          <tr>
            <td>
              [[HostDefined]]
            </td>
            <td>
              anything (default value is ~empty~)
            </td>
            <td></td>
          </tr>
        </table>
      </emu-table>
    </emu-clause>

    <emu-clause id="sec-parse-script" type="abstract operation">
      <h1>
        ParseScript (
          _sourceText_: ECMAScript source text,
          _realm_: unknown,
          _hostDefined_: unknown,
        ): a Script Record or a non-empty List of *SyntaxError* objects
      </h1>
      <dl class="header">
        <dt>description</dt>
        <dd>It creates a Script Record based upon the result of parsing _sourceText_ as a |Script|.</dd>
      </dl>

      <emu-alg>
        1. Let _script_ be ParseText(_sourceText_, |Script|).
        1. If _script_ is a List of errors, return _script_.
        1. Return Script Record { [[Realm]]: _realm_, [[ECMAScriptCode]]: _script_, <ins>[[LoadedModules]]: a new empty List, [[LoadingModules]]: a new empty List,</ins> [[HostDefined]]: _hostDefined_ }.
      </emu-alg>
    </emu-clause>
  </emu-clause>

  <emu-clause id="sec-modules">
    <h1>Modules</h1>

    <emu-clause id="sec-module-semantics">
      <h1>Module Semantics</h1>

      <emu-clause id="sec-placeholder-16.2.1.1"><h1></h1></emu-clause>
      <emu-clause id="sec-placeholder-16.2.1.2"><h1></h1></emu-clause>
      <emu-clause id="sec-placeholder-16.2.1.3"><h1></h1></emu-clause>
      <emu-clause id="sec-placeholder-16.2.1.4"><h1></h1></emu-clause>

      <emu-clause id="sec-cyclic-module-records">
        <h1>Cyclic Module Records</h1>
        <p>A <dfn id="cyclic-module-record" variants="Cyclic Module Records">Cyclic Module Record</dfn> is used to represent information about a module that can participate in dependency cycles with other modules that are subclasses of the Cyclic Module Record type. Module Records that are not subclasses of the Cyclic Module Record type must not participate in dependency cycles with Source Text Module Records.</p>
        <p>In addition to the fields defined in <emu-xref href="#table-module-record-fields"></emu-xref> Cyclic Module Records have the additional fields listed in <emu-xref href="#table-cyclic-module-fields"></emu-xref></p>
        <emu-table id="table-cyclic-module-fields" caption="Additional Fields of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                [[Status]]
              </td>
              <td>
                <ins>~new~</ins>, ~unlinked~, ~linking~, ~linked~, ~evaluating~, ~evaluating-async~, or ~evaluated~
              </td>
              <td>
                Initially <del>~unlinked~</del><ins>~new~</ins>. Transitions to <ins>~unlinked~,</ins> ~linking~, ~linked~, ~evaluating~, possibly ~evaluating-async~, ~evaluated~ (in that order) as the module progresses throughout its lifecycle. ~evaluating-async~ indicates this module is queued to execute on completion of its asynchronous dependencies or it is a module whose [[HasTLA]] field is *true* that has been executed and is pending top-level completion.
              </td>
            </tr>
            <tr>
              <td>
                [[EvaluationError]]
              </td>
              <td>
                a throw completion or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[DFSAncestorIndex]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[RequestedModules]]
              </td>
              <td>
                a List of Strings
              </td>
              <td>
                A List of all the |ModuleSpecifier| strings used by the module represented by this record to request the importation of a module. The List is source text occurrence ordered.
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[LoadedModules]]</ins>
              </td>
              <td>
                <ins>a List of Record { [[Specifier]]: a String, [[Module]]: a Module Record }</ins>
              </td>
              <td>
                <ins>A map from the specifier strings used by the module represented by this record to request the importation of a module to the resolved Module Record. The list does not contain two different Records with the same [[Specifier]].</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[LoadingModules]]</ins>
              </td>
              <td>
                <ins>a List of Records { [[Specifier]]: a String, [[LoadStates]]: a List of ModuleLoadState Records }</ins>
              </td>
              <td>
                <ins>A map from the specifier strings imported by this script to the loading processes that are waiting for the resolved module record. It is used to avoid multiple calls to HostLoadImportedModule with the same (_specifier_, _referrer_) pair. The list does not contain two different Records with the same [[Specifier]].</ins>
              </td>
            </tr>
            <tr>
              <td>
                [[CycleRoot]]
              </td>
              <td>
                a Cyclic Module Record or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[HasTLA]]
              </td>
              <td>
                a Boolean
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncEvaluation]]
              </td>
              <td>
                a Boolean
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[TopLevelCapability]]
              </td>
              <td>
                a PromiseCapability Record or ~empty~
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[AsyncParentModules]]
              </td>
              <td>
                a List of Cyclic Module Records
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                [[PendingAsyncDependencies]]
              </td>
              <td>
                an integer or ~empty~
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>
        <p>In addition to the methods defined in <emu-xref href="#table-abstract-methods-of-module-records"></emu-xref> Cyclic Module Records have the additional methods listed in <emu-xref href="#table-cyclic-module-methods"></emu-xref></p>
        <emu-table id="table-cyclic-module-methods" caption="Additional Abstract Methods of Cyclic Module Records">
          <table>
            <tr>
              <th>
                Method
              </th>
              <th>
                Purpose
              </th>
            </tr>
            <tr>
              <td>
                InitializeEnvironment()
              </td>
              <td></td>
            </tr>
            <tr>
              <td>
                ExecuteModule( [ _promiseCapability_ ] )
              </td>
              <td></td>
            </tr>
          </table>
        </emu-table>

        <p><ins>A <dfn id="moduleloadstate-record" variants="ModuleLoadState Records">ModuleLoadState Record</dfn> is a Record that contains information about the loading process of a module graph. It's used to continue loading after a call to LoadImportedModule. Each ModuleLoadState Record has the fields defined in <emu-xref href="#table-moduleloadstate-record-fields"></emu-xref>:</ins></p>
        <emu-table id="table-moduleloadstate-record-fields" caption="ModuleLoadState Record Fields">
          <table>
            <tr>
              <th>
                Field Name
              </th>
              <th>
                Value Type
              </th>
              <th>
                Meaning
              </th>
            </tr>
            <tr>
              <td>
                <ins>[[Action]]</ins>
              </td>
              <td>
                <ins>~graph-loading~ or ~dynamic-import~</ins>
              </td>
              <td>
                <ins>The action that caused the call to LoadImportedModule. It is ~graph-loading~ when loading the dependencies of a module; it is ~dynamic-import~ when loading a module that was requested by an `import()` call.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[PromiseCapability]]</ins>
              </td>
              <td>
                <ins>a PromiseCapability Record</ins>
              </td>
              <td>
                <ins>The promise to resolve when the loading process finishes.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[IsLoading]]</ins>
              </td>
              <td>
                <ins>a boolean</ins>
              </td>
              <td>
                <ins>This field is only used if [[Action]] is ~graph-loading~. It is true if the loading process has not finished yet, neither successfully nor with an error.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[PendingModules]]</ins>
              </td>
              <td>
                <ins>a non-negative integer</ins>
              </td>
              <td>
                <ins>This field is only used if [[Action]] is ~graph-loading~. It tracks the number of pending HostResolveImportedModule calls.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[Visited]]</ins>
              </td>
              <td>
                <ins>a List of Cyclic Module Records</ins>
              </td>
              <td>
                <ins>This field is only used if [[Action]] is ~graph-loading~. It is a list of the Cyclic Module Records that have been already loaded by the current loading process, to avoid infinite loops with circular dependencies.</ins>
              </td>
            </tr>
            <tr>
              <td>
                <ins>[[HostDefined]]</ins>
              </td>
              <td>
                <ins>anything (default value is *undefined*)</ins>
              </td>
              <td>
                <ins>It contains host-defined data to pass from the LoadRequestedModules caller to HostLoadImportedModule.</ins>
              </td>
            </tr>
          </table>
        </emu-table>

        <emu-clause id="sec-LoadRequestedModules" type="concrete method">
          <h1>
            <ins>
              LoadRequestedModules ( [ _hostDefined_ ] ): a Promise object
            </ins>
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>It populates the [[LoadedModules]] of all the Modue Records in the dependency graph of _module_ (most of the work is done by the auxiliary function InnerModuleLoading). It takes an optional _hostDefined_ parameter, that is passed to the HostLoadImportedModule hook.</dd>
          </dl>

          <emu-alg>
            1. If _hostDefined_ is not present, let _hostDefined_ be *undefined*.
            1. Let _pc_ be ! NewPromiseCapability(%Promise%).
            1. Let _state_ be a new ModuleLoadState Record { [[Action]]: ~graph-loading~, [[IsLoading]]: *true*, [[PendingModules]]: 1, [[Visited]]: a new empty List, [[PromiseCapability]]: _pc_, [[HostDefined]]: _hostDefined_ }.
            1. Perform InnerModuleLoading(_state_, _module_).
            1. Return _pc_.[[Promise]].
          </emu-alg>

          <emu-note>
            The _hostDefined_ parameter can be used to pass additional information necessary to fetch the imported modules. It is used, for example, by HTML to set the correct fetch destination for <code>&lt;link rel="preload" as="..."&gt;</code> tags.
            Note that <code>import()</code> expressions never set the _hostDefined_ parameter.
          </emu-note>

          <emu-clause id="sec-InnerModuleLoading" type="abstract operation">
            <h1>
              <ins>
                InnerModuleLoading (
                  _state_: a ModuleLoadState Record whose [[Action]] is ~graph-loading~,
                  _module_: a Module Record,
                ): ~unused~
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by LoadRequestedModules to recursively perform the actual loading process for _module_'s dependency graph.</dd>
            </dl>

            <emu-alg>
              1. Assert: _state_.[[IsLoading]] is *true*.
              1. If _module_ is a Cyclic Module Record, _module_.[[Status]] is ~new~, and _state_.[[Visited]] does not contain _module_, then
                1. Add _module_ to _state_.[[Visited]].
                1. Let _requestedModulesCount_ be the length of _module_.[[RequestedModules]].
                1. Set _state_.[[PendingModules]] to _state_.[[PendingModules]] + _requestedModulesCount_.
                1. For each String _required_ of _module_.[[RequestedModules]], do
                  1. Perform LoadImportedModule(_module_, _required_, _state_).
                  1. NOTE: LoadImportedModule will call ContinueModuleLoading.
              1. Assert: _state_.[[PendingModules]] &ge; 1.
              1. Set _state_.[[PendingModules]] to _state_.[[PendingModules]] - 1.
              1. If _state_.[[PendingModules]] = 0, then
                1. Set _state_.[[IsLoading]] to *false*.
                1. For each Cyclic Module Record _loaded_ in _state_.[[Visited]], do
                  1. If _loaded_.[[Status]] is ~new~, set _loaded_.[[Status]] to ~unlinked~.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Resolve]], *undefined*, &laquo; *undefined* &raquo;).
            </emu-alg>
          </emu-clause>

          <emu-clause id="sec-ContinueModuleLoading" type="abstract operation">
            <h1>
              <ins>
                ContinueModuleLoading (
                  _state_: a ModuleLoadState Record whose [[Action]] is ~graph-loading~,
                  _result_: either a normal completion containing a Module Record or a throw completion,
                ): ~unused~
              </ins>
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used to re-enter the loading process after a call to LoadImportedModule.</dd>
            </dl>

            <emu-alg>
              1. If _state_.[[IsLoading]] is *false*, return.
              1. If _result_ is a normal completion, then
                1. Perform InnerModuleLoading(_state_, _result_.[[Value]]).
              1. Else,
                1. Set _state_.[[IsLoading]] to *false*.
                1. Perform ! Call(_state_.[[PromiseCapability]].[[Reject]], *undefined*, &laquo; _result_.[[Value]] &raquo;).
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-moduledeclarationlinking" type="concrete method" oldids="sec-moduledeclarationinstantiation">
          <h1>Link ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Cyclic Module Record _module_</dd>

            <dt>description</dt>
            <dd>On success, Link transitions this module's [[Status]] from ~unlinked~ to ~linked~. On failure, an exception is thrown and this module's [[Status]] remains ~unlinked~. (Most of the work is done by the auxiliary function InnerModuleLinking.)</dd>
          </dl>

          <emu-alg>
            1. Assert: _module_.[[Status]] is <del>not ~linking~ or ~evaluating~</del><ins>~unlinked~, ~linked~, ~evaluating-async~, or ~evaluated~</ins>.
            1. Let _stack_ be a new empty List.
            1. Let _result_ be Completion(InnerModuleLinking(_module_, _stack_, 0)).
            1. If _result_ is an abrupt completion, then
              1. For each Cyclic Module Record _m_ of _stack_, do
                1. Assert: _m_.[[Status]] is ~linking~.
                1. Set _m_.[[Status]] to ~unlinked~.
              1. Assert: _module_.[[Status]] is ~unlinked~.
              1. Return ? _result_.
            1. Assert: _module_.[[Status]] is ~linked~, ~evaluating-async~, or ~evaluated~.
            1. Assert: _stack_ is empty.
            1. Return ~unused~.
          </emu-alg>

          <emu-clause id="sec-InnerModuleLinking" type="abstract operation" oldids="sec-innermoduleinstantiation">
            <h1>
              InnerModuleLinking (
                _module_: a Module Record,
                _stack_: unknown,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Link to perform the actual linking process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as a module's [[DFSIndex]] and [[DFSAncestorIndex]] fields, keep track of the depth-first search (DFS) traversal. In particular, [[DFSAncestorIndex]] is used to discover strongly connected components (SCCs), such that all modules in an SCC transition to ~linked~ together.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Perform ? _module_.Link().
                1. Return _index_.
              1. If _module_.[[Status]] is ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~, then
                1. Return _index_.
              1. Assert: _module_.[[Status]] is ~unlinked~.
              1. Set _module_.[[Status]] to ~linking~.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _index_ to _index_ + 1.
              1. Append _module_ to _stack_.
              1. For each String _required_ of _module_.[[RequestedModules]], do
                1. Let _requiredModule_ be <del>? HostResolveImportedModule</del><ins>GetImportedModule</ins>(_module_, _required_).
                1. <ins>Assert: _requiredModule_ is not ~empty~, because LoadRequestedModules must have completed successfully prior to invoking this method.</ins>
                1. Set _index_ to ? InnerModuleLinking(_requiredModule_, _stack_, _index_).
                1. If _requiredModule_ is a Cyclic Module Record, then
                  1. Assert: _requiredModule_.[[Status]] is either ~linking~, ~linked~, ~evaluating-async~, or ~evaluated~.
                  1. Assert: _requiredModule_.[[Status]] is ~linking~ if and only if _requiredModule_ is in _stack_.
                  1. If _requiredModule_.[[Status]] is ~linking~, then
                    1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
              1. Perform ? _module_.InitializeEnvironment().
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] &le; _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element in _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. Set _requiredModule_.[[Status]] to ~linked~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
              1. Return _index_.
            </emu-alg>
          </emu-clause>
        </emu-clause>

        <emu-clause id="sec-moduleevaluation">
          <h1>Evaluate ( )</h1>

          <emu-clause id="sec-innermoduleevaluation" type="abstract operation">
            <h1>
              InnerModuleEvaluation (
                _module_: a Module Record,
                _stack_: unknown,
                _index_: a non-negative integer,
              ): either a normal completion containing a non-negative integer or a throw completion
            </h1>
            <dl class="header">
              <dt>description</dt>
              <dd>It is used by Evaluate to perform the actual evaluation process for _module_, as well as recursively on all other modules in the dependency graph. The _stack_ and _index_ parameters, as well as _module_'s [[DFSIndex]] and [[DFSAncestorIndex]] fields, are used the same way as in InnerModuleLinking.</dd>
            </dl>

            <emu-alg>
              1. If _module_ is not a Cyclic Module Record, then
                1. Let _promise_ be ! _module_.Evaluate().
                1. Assert: _promise_.[[PromiseState]] is not ~pending~.
                1. If _promise_.[[PromiseState]] is ~rejected~, then
                  1. Return ThrowCompletion(_promise_.[[PromiseResult]]).
                1. Return _index_.
              1. If _module_.[[Status]] is ~evaluating-async~ or ~evaluated~, then
                1. If _module_.[[EvaluationError]] is ~empty~, return _index_.
                1. Otherwise, return ? _module_.[[EvaluationError]].
              1. If _module_.[[Status]] is ~evaluating~, return _index_.
              1. Assert: _module_.[[Status]] is ~linked~.
              1. Set _module_.[[Status]] to ~evaluating~.
              1. Set _module_.[[DFSIndex]] to _index_.
              1. Set _module_.[[DFSAncestorIndex]] to _index_.
              1. Set _module_.[[PendingAsyncDependencies]] to 0.
              1. Set _index_ to _index_ + 1.
              1. Append _module_ to _stack_.
              1. For each String _required_ of _module_.[[RequestedModules]], do
                1. Let _requiredModule_ be <del>! HostResolveImportedModule</del><ins>GetImportedModule</ins>(_module_, _required_).
                1. <del>NOTE: Link must be completed successfully prior to invoking this method, so every requested module is guaranteed to resolve successfully.</del>
                1. <ins>Assert: _requiredModule_ is not ~empty~, because LoadRequestedModules must have completed successfully prior to invoking this method.</ins>
                1. Set _index_ to ? InnerModuleEvaluation(_requiredModule_, _stack_, _index_).
                1. If _requiredModule_ is a Cyclic Module Record, then
                  1. Assert: _requiredModule_.[[Status]] is either ~evaluating~, ~evaluating-async~, or ~evaluated~.
                  1. Assert: _requiredModule_.[[Status]] is ~evaluating~ if and only if _requiredModule_ is in _stack_.
                  1. If _requiredModule_.[[Status]] is ~evaluating~, then
                    1. Set _module_.[[DFSAncestorIndex]] to min(_module_.[[DFSAncestorIndex]], _requiredModule_.[[DFSAncestorIndex]]).
                  1. Else,
                    1. Set _requiredModule_ to _requiredModule_.[[CycleRoot]].
                    1. Assert: _requiredModule_.[[Status]] is ~evaluating-async~ or ~evaluated~.
                    1. If _requiredModule_.[[EvaluationError]] is not ~empty~, return ? _requiredModule_.[[EvaluationError]].
                  1. If _requiredModule_.[[AsyncEvaluation]] is *true*, then
                    1. Set _module_.[[PendingAsyncDependencies]] to _module_.[[PendingAsyncDependencies]] + 1.
                    1. Append _module_ to _requiredModule_.[[AsyncParentModules]].
              1. If _module_.[[PendingAsyncDependencies]] &gt; 0 or _module_.[[HasTLA]] is *true*, then
                1. Assert: _module_.[[AsyncEvaluation]] is *false* and was never previously set to *true*.
                1. Set _module_.[[AsyncEvaluation]] to *true*.
                1. NOTE: The order in which module records have their [[AsyncEvaluation]] fields transition to *true* is significant. (See <emu-xref href="#sec-async-module-execution-fulfilled"></emu-xref>.)
                1. If _module_.[[PendingAsyncDependencies]] is 0, perform ExecuteAsyncModule(_module_).
              1. Otherwise, perform ? <emu-meta effects="user-code">_module_.ExecuteModule()</emu-meta>.
              1. Assert: _module_ occurs exactly once in _stack_.
              1. Assert: _module_.[[DFSAncestorIndex]] &le; _module_.[[DFSIndex]].
              1. If _module_.[[DFSAncestorIndex]] = _module_.[[DFSIndex]], then
                1. Let _done_ be *false*.
                1. Repeat, while _done_ is *false*,
                  1. Let _requiredModule_ be the last element in _stack_.
                  1. Remove the last element of _stack_.
                  1. Assert: _requiredModule_ is a Cyclic Module Record.
                  1. If _requiredModule_.[[AsyncEvaluation]] is *false*, set _requiredModule_.[[Status]] to ~evaluated~.
                  1. Otherwise, set _requiredModule_.[[Status]] to ~evaluating-async~.
                  1. If _requiredModule_ and _module_ are the same Module Record, set _done_ to *true*.
                  1. Set _requiredModule_.[[CycleRoot]] to _module_.
              1. Return _index_.
            </emu-alg>
          </emu-clause>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-source-text-module-records">
        <h1>Source Text Module Records</h1>

        <p>The following definitions specify the required concrete methods and other abstract operations for Source Text Module Records</p>

        <emu-clause id="sec-parsemodule" type="abstract operation">
          <h1>
            ParseModule (
              _sourceText_: ECMAScript source text,
              _realm_: unknown,
              _hostDefined_: unknown,
            ): a Source Text Module Record or a non-empty List of *SyntaxError* objects
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd>It creates a Source Text Module Record based upon the result of parsing _sourceText_ as a |Module|.</dd>
          </dl>
          <emu-alg>
            1. Let _body_ be ParseText(_sourceText_, |Module|).
            1. If _body_ is a List of errors, return _body_.
            1. Let _requestedModules_ be the ModuleRequests of _body_.
            1. Let _importEntries_ be ImportEntries of _body_.
            1. Let _importedBoundNames_ be ImportedLocalNames(_importEntries_).
            1. Let _indirectExportEntries_ be a new empty List.
            1. Let _localExportEntries_ be a new empty List.
            1. Let _starExportEntries_ be a new empty List.
            1. Let _exportEntries_ be ExportEntries of _body_.
            1. For each ExportEntry Record _ee_ of _exportEntries_, do
              1. If _ee_.[[ModuleRequest]] is *null*, then
                1. If _ee_.[[LocalName]] is not an element of _importedBoundNames_, then
                  1. Append _ee_ to _localExportEntries_.
                1. Else,
                  1. Let _ie_ be the element of _importEntries_ whose [[LocalName]] is the same as _ee_.[[LocalName]].
                  1. If _ie_.[[ImportName]] is ~namespace-object~, then
                    1. NOTE: This is a re-export of an imported module namespace object.
                    1. Append _ee_ to _localExportEntries_.
                  1. Else,
                    1. NOTE: This is a re-export of a single name.
                    1. Append the ExportEntry Record { [[ModuleRequest]]: _ie_.[[ModuleRequest]], [[ImportName]]: _ie_.[[ImportName]], [[LocalName]]: *null*, [[ExportName]]: _ee_.[[ExportName]] } to _indirectExportEntries_.
              1. Else if _ee_.[[ImportName]] is ~all-but-default~, then
                1. Assert: _ee_.[[ExportName]] is *null*.
                1. Append _ee_ to _starExportEntries_.
              1. Else,
                1. Append _ee_ to _indirectExportEntries_.
            1. Let _async_ be _body_ Contains `await`.
            1. Return Source Text Module Record { [[Realm]]: _realm_, [[Environment]]: ~empty~, [[Namespace]]: ~empty~, [[CycleRoot]]: ~empty~, [[HasTLA]]: _async_, [[AsyncEvaluation]]: *false*, [[TopLevelCapability]]: ~empty~, [[AsyncParentModules]]: &laquo; &raquo;, [[PendingAsyncDependencies]]: ~empty~, [[Status]]: <del>~unlinked~</del><ins>~new~</ins>, [[EvaluationError]]: ~empty~, [[HostDefined]]: _hostDefined_, [[ECMAScriptCode]]: _body_, [[Context]]: ~empty~, [[ImportMeta]]: ~empty~, [[RequestedModules]]: _requestedModules_, <ins>[[LoadedModules]]: a new empty List, [[LoadingModules]]: a new empty List,</ins> [[ImportEntries]]: _importEntries_, [[LocalExportEntries]]: _localExportEntries_, [[IndirectExportEntries]]: _indirectExportEntries_, [[StarExportEntries]]: _starExportEntries_, [[DFSIndex]]: ~empty~, [[DFSAncestorIndex]]: ~empty~ }.
          </emu-alg>
          <emu-note>
            <p>An implementation may parse module source text and analyse it for Early Error conditions prior to the evaluation of ParseModule for that module source text. However, the reporting of any errors must be deferred until the point where this specification actually performs ParseModule upon that source text.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-getexportednames" type="concrete method">
          <h1>
            GetExportedNames (
              optional _exportStarSet_: a List of Source Text Module Records,
            ): either a normal completion containing a List of either Strings or *null*, or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>
          <emu-alg>
            1. If _exportStarSet_ is not present, set _exportStarSet_ to a new empty List.
            1. If _exportStarSet_ contains _module_, then
              1. Assert: We've reached the starting point of an `export *` circularity.
              1. Return a new empty List.
            1. Append _module_ to _exportStarSet_.
            1. Let _exportedNames_ be a new empty List.
            1. For each ExportEntry Record _e_ of _module_.[[LocalExportEntries]], do
              1. Assert: _module_ provides the direct binding for this export.
              1. Append _e_.[[ExportName]] to _exportedNames_.
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. Assert: _module_ imports a specific binding for this export.
              1. Append _e_.[[ExportName]] to _exportedNames_.
            1. For each ExportEntry Record _e_ of _module_.[[StarExportEntries]], do
              1. Let _requestedModule_ be <del>? HostResolveImportedModule</del><ins>GetImportedModule</ins>(_module_, _e_.[[ModuleRequest]]).
              1. <ins>Assert: _requestedModule_ is not ~empty~, because LoadRequestedModules must have completed successfully prior to invoking this method.</ins>
              1. Let _starNames_ be ? _requestedModule_.GetExportedNames(_exportStarSet_).
              1. For each element _n_ of _starNames_, do
                1. If SameValue(_n_, *"default"*) is *false*, then
                  1. If _n_ is not an element of _exportedNames_, then
                    1. Append _n_ to _exportedNames_.
            1. Return _exportedNames_.
          </emu-alg>
          <emu-note>
            <p>GetExportedNames does not filter out or throw an exception for names that have ambiguous star export bindings.</p>
          </emu-note>
        </emu-clause>

        <emu-clause id="sec-resolveexport" type="concrete method">
          <h1>
            ResolveExport (
              _exportName_: a String,
              optional _resolveSet_: a List of Records that have [[Module]] and [[ExportName]] fields,
            ): either a normal completion containing either a ResolvedBinding Record, *null*, or ~ambiguous~, or a throw completion
          </h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>

            <dt>description</dt>
            <dd>
              <p>ResolveExport attempts to resolve an imported binding to the actual defining module and local binding name. The defining module may be the module represented by the Module Record this method was invoked on or some other module that is imported by that module. The parameter _resolveSet_ is used to detect unresolved circular import/export paths. If a pair consisting of specific Module Record and _exportName_ is reached that is already in _resolveSet_, an import circularity has been encountered. Before recursively calling ResolveExport, a pair consisting of _module_ and _exportName_ is added to _resolveSet_.</p>
              <p>If a defining module is found, a ResolvedBinding Record { [[Module]], [[BindingName]] } is returned. This record identifies the resolved binding of the originally requested export, unless this is the export of a namespace with no local binding. In this case, [[BindingName]] will be set to ~namespace~. If no definition was found or the request is found to be circular, *null* is returned. If the request is found to be ambiguous, ~ambiguous~ is returned.</p>
            </dd>
          </dl>

          <emu-alg>
            1. If _resolveSet_ is not present, set _resolveSet_ to a new empty List.
            1. For each Record { [[Module]], [[ExportName]] } _r_ of _resolveSet_, do
              1. If _module_ and _r_.[[Module]] are the same Module Record and SameValue(_exportName_, _r_.[[ExportName]]) is *true*, then
                1. Assert: This is a circular import request.
                1. Return *null*.
            1. Append the Record { [[Module]]: _module_, [[ExportName]]: _exportName_ } to _resolveSet_.
            1. For each ExportEntry Record _e_ of _module_.[[LocalExportEntries]], do
              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then
                1. Assert: _module_ provides the direct binding for this export.
                1. Return ResolvedBinding Record { [[Module]]: _module_, [[BindingName]]: _e_.[[LocalName]] }.
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. If SameValue(_exportName_, _e_.[[ExportName]]) is *true*, then
                1. Let _importedModule_ be <del>? HostResolveImportedModule</del><ins>GetImportedModule</ins>(_module_, _e_.[[ModuleRequest]]).
                1. <ins>Assert: _importedModule_ is not ~empty~, because LoadRequestedModules must have completed successfully prior to invoking this method.</ins>
                1. If _e_.[[ImportName]] is ~all~, then
                  1. Assert: _module_ does not provide the direct binding for this export.
                  1. Return ResolvedBinding Record { [[Module]]: _importedModule_, [[BindingName]]: ~namespace~ }.
                1. Else,
                  1. Assert: _module_ imports a specific binding for this export.
                  1. Return ? _importedModule_.ResolveExport(_e_.[[ImportName]], _resolveSet_).
            1. If SameValue(_exportName_, *"default"*) is *true*, then
              1. Assert: A `default` export was not explicitly defined by this module.
              1. Return *null*.
              1. NOTE: A `default` export cannot be provided by an `export * from "mod"` declaration.
            1. Let _starResolution_ be *null*.
            1. For each ExportEntry Record _e_ of _module_.[[StarExportEntries]], do
              1. Let _importedModule_ be <del>? HostResolveImportedModule</del><ins>GetImportedModule</ins>(_module_, _e_.[[ModuleRequest]]).
              1. <ins>Assert: _importedModule_ is not ~empty~, because LoadRequestedModules must have completed successfully prior to invoking this method.</ins>
              1. Let _resolution_ be ? _importedModule_.ResolveExport(_exportName_, _resolveSet_).
              1. If _resolution_ is ~ambiguous~, return ~ambiguous~.
              1. If _resolution_ is not *null*, then
                1. Assert: _resolution_ is a ResolvedBinding Record.
                1. If _starResolution_ is *null*, set _starResolution_ to _resolution_.
                1. Else,
                  1. Assert: There is more than one `*` import that includes the requested name.
                  1. If _resolution_.[[Module]] and _starResolution_.[[Module]] are not the same Module Record, return ~ambiguous~.
                  1. If _resolution_.[[BindingName]] is ~namespace~ and _starResolution_.[[BindingName]] is not ~namespace~, or if _resolution_.[[BindingName]] is not ~namespace~ and _starResolution_.[[BindingName]] is ~namespace~, return ~ambiguous~.
                  1. If _resolution_.[[BindingName]] is a String, _starResolution_.[[BindingName]] is a String, and SameValue(_resolution_.[[BindingName]], _starResolution_.[[BindingName]]) is *false*, return ~ambiguous~.
            1. Return _starResolution_.
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-source-text-module-record-initialize-environment" type="concrete method">
          <h1>InitializeEnvironment ( ): either a normal completion containing ~unused~ or a throw completion</h1>
          <dl class="header">
            <dt>for</dt>
            <dd>a Source Text Module Record _module_</dd>
          </dl>

          <emu-alg>
            1. For each ExportEntry Record _e_ of _module_.[[IndirectExportEntries]], do
              1. Let _resolution_ be ? _module_.ResolveExport(_e_.[[ExportName]]).
              1. If _resolution_ is *null* or ~ambiguous~, throw a *SyntaxError* exception.
              1. Assert: _resolution_ is a ResolvedBinding Record.
            1. Assert: All named exports from _module_ are resolvable.
            1. Let _realm_ be _module_.[[Realm]].
            1. Assert: _realm_ is not *undefined*.
            1. Let _env_ be NewModuleEnvironment(_realm_.[[GlobalEnv]]).
            1. Set _module_.[[Environment]] to _env_.
            1. For each ImportEntry Record _in_ of _module_.[[ImportEntries]], do
              1. Let _importedModule_ be <del>? HostResolveImportedModule</del><ins>GetImportedModule</ins>(_module_, _in_.[[ModuleRequest]]).
              1. <ins>Assert: _importedModule_ is not ~empty~, because LoadRequestedModules must have completed successfully prior to invoking this method.</ins>
              1. NOTE: The above call cannot fail because imported module requests are a subset of _module_.[[RequestedModules]], and these have been resolved earlier in this algorithm.
              1. If _in_.[[ImportName]] is ~namespace-object~, then
                1. Let _namespace_ be ? GetModuleNamespace(_importedModule_).
                1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
              1. Else,
                1. Let _resolution_ be ? _importedModule_.ResolveExport(_in_.[[ImportName]]).
                1. If _resolution_ is *null* or ~ambiguous~, throw a *SyntaxError* exception.
                1. If _resolution_.[[BindingName]] is ~namespace~, then
                  1. Let _namespace_ be ? GetModuleNamespace(_resolution_.[[Module]]).
                  1. Perform ! _env_.CreateImmutableBinding(_in_.[[LocalName]], *true*).
                  1. Perform ! _env_.InitializeBinding(_in_.[[LocalName]], _namespace_).
                1. Else,
                  1. Perform _env_.CreateImportBinding(_in_.[[LocalName]], _resolution_.[[Module]], _resolution_.[[BindingName]]).
            1. Let _moduleContext_ be a new ECMAScript code execution context.
            1. Set the Function of _moduleContext_ to *null*.
            1. Assert: _module_.[[Realm]] is not *undefined*.
            1. Set the Realm of _moduleContext_ to _module_.[[Realm]].
            1. Set the ScriptOrModule of _moduleContext_ to _module_.
            1. Set the VariableEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the LexicalEnvironment of _moduleContext_ to _module_.[[Environment]].
            1. Set the PrivateEnvironment of _moduleContext_ to *null*.
            1. Set _module_.[[Context]] to _moduleContext_.
            1. Push _moduleContext_ onto the execution context stack; _moduleContext_ is now the running execution context.
            1. Let _code_ be _module_.[[ECMAScriptCode]].
            1. Let _varDeclarations_ be the VarScopedDeclarations of _code_.
            1. Let _declaredVarNames_ be a new empty List.
            1. For each element _d_ of _varDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If _dn_ is not an element of _declaredVarNames_, then
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                  1. Perform ! _env_.InitializeBinding(_dn_, *undefined*).
                  1. Append _dn_ to _declaredVarNames_.
            1. Let _lexDeclarations_ be the LexicallyScopedDeclarations of _code_.
            1. Let _privateEnv_ be *null*.
            1. For each element _d_ of _lexDeclarations_, do
              1. For each element _dn_ of the BoundNames of _d_, do
                1. If IsConstantDeclaration of _d_ is *true*, then
                  1. Perform ! _env_.CreateImmutableBinding(_dn_, *true*).
                1. Else,
                  1. Perform ! _env_.CreateMutableBinding(_dn_, *false*).
                1. If _d_ is a |FunctionDeclaration|, a |GeneratorDeclaration|, an |AsyncFunctionDeclaration|, or an |AsyncGeneratorDeclaration|, then
                  1. Let _fo_ be InstantiateFunctionObject of _d_ with arguments _env_ and _privateEnv_.
                  1. Perform ! _env_.InitializeBinding(_dn_, _fo_).
            1. Remove _moduleContext_ from the execution context stack.
            1. Return ~unused~.
          </emu-alg>
        </emu-clause>
      </emu-clause>

      <emu-clause id="sec-hostresolveimportedmodule" type="host-defined abstract operation">
        <h1>
          <del>
            HostResolveImportedModule (
              _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
              _specifier_: a |ModuleSpecifier| String,
            ): either a normal completion containing a Module Record or a throw completion
          </del>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It provides the concrete Module Record subclass instance that corresponds to _specifier_ occurring within the context of the script or module represented by _referencingScriptOrModule_. _referencingScriptOrModule_ may be *null* if the resolution is being performed in the context of an <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression and there is no active script or module at that time.</dd>
        </dl>

        <emu-note>
          <p>An example of when _referencingScriptOrModule_ can be *null* is in a web browser host. There, if a user clicks on a control given by</p>

          <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

          <p>there will be no active script or module at the time the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression runs. More generally, this can happen in any situation where the host pushes execution contexts with *null* ScriptOrModule components onto the execution context stack.</p>
        </emu-note>

        <p>An implementation of HostResolveImportedModule must conform to the following requirements:</p>
        <ul>
          <li>
            If the returned Completion Record is a normal completion, it must be a normal completion containing an instance of a concrete subclass of Module Record.
          </li>
          <li>
            If a Module Record corresponding to the pair _referencingScriptOrModule_, _specifier_ does not exist or cannot be created, an exception must be thrown.
          </li>
          <li>
            Each time this operation is called with a specific _referencingScriptOrModule_, _specifier_ pair as arguments it must return the same Module Record instance if it completes normally.
          </li>
        </ul>
        <p>Multiple different _referencingScriptOrModule_, _specifier_ pairs may map to the same Module Record instance. The actual mapping semantic is host-defined but typically a normalization process is applied to _specifier_ as part of the mapping process. A typical normalization process would include actions such as alphabetic case folding and expansion of relative and abbreviated path specifiers.</p>
      </emu-clause>

      <emu-clause id="sec-hostimportmoduledynamically" type="host-defined abstract operation">
        <h1>
          <del>
            HostImportModuleDynamically (
              _referencingScriptOrModule_: a Script Record, a Module Record, or *null*,
              _specifier_: a |ModuleSpecifier| String,
              _promiseCapability_: a PromiseCapability Record,
            ): ~unused~
          </del>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>It performs any necessary setup work in order to make available the module corresponding to _specifier_ occurring within the context of the script or module represented by _referencingScriptOrModule_. _referencingScriptOrModule_ may be *null* if there is no active script or module when the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression occurs. It then performs FinishDynamicImport to finish the dynamic import process.</dd>
        </dl>
        <p>An implementation of HostImportModuleDynamically must conform to the following requirements:</p>

        <ul>
          <li>
            It must return ~unused~. Success or failure must instead be signaled as discussed below.
          </li>
          <li>
            The host environment must conform to one of the two following sets of requirements:
            <dl>
              <dt>Success path</dt>

              <dd>
                <ul>
                  <li>At some future time, the host environment must perform FinishDynamicImport(_referencingScriptOrModule_, _specifier_, _promiseCapability_, _promise_), where _promise_ is a Promise resolved with *undefined*.</li>

                  <li>Any subsequent call to HostResolveImportedModule after FinishDynamicImport has completed, given the arguments _referencingScriptOrModule_ and _specifier_, must return a normal completion containing a module which has already been evaluated, i.e. whose Evaluate concrete method has already been called and returned a normal completion.</li>
                </ul>
              </dd>

              <dt>Failure path</dt>

              <dd>
                <ul>
                  <li>At some future time, the host environment must perform FinishDynamicImport(_referencingScriptOrModule_, _specifier_, _promiseCapability_, _promise_), where _promise_ is a Promise rejected with an error representing the cause of failure.</li>
                </ul>
              </dd>
            </dl>
          </li>
          <li>
            If the host environment takes the success path once for a given _referencingScriptOrModule_, _specifier_ pair, it must always do so for subsequent calls.
          </li>
          <li>
            The operation must not call _promiseCapability_.[[Resolve]] or _promiseCapability_.[[Reject]], but instead must treat _promiseCapability_ as an opaque identifying value to be passed through to FinishDynamicImport.
          </li>
        </ul>

        <p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to allow HostResolveImportedModule to synchronously retrieve the appropriate Module Record, and then calling its Evaluate concrete method. This might require performing similar normalization as HostResolveImportedModule does.</p>
      </emu-clause>

      <emu-clause id="sec-finishdynamicimport" type="abstract operation">
        <h1>
          <del>
            FinishDynamicImport (
              _referencingScriptOrModule_: unknown,
              _specifier_: unknown,
              _promiseCapability_: a PromiseCapability Record,
              _innerPromise_: unknown,
            ): ~unused~
          </del>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd>FinishDynamicImport completes the process of a dynamic import originally started by an <emu-xref href="#sec-import-calls">`import()`</emu-xref> call, resolving or rejecting the promise returned by that call as appropriate according to _innerPromise_'s resolution. It is performed by host environments as part of HostImportModuleDynamically.</dd>
        </dl>
        <emu-alg>
          1. Let _fulfilledClosure_ be a new Abstract Closure with parameters (_result_) that captures _referencingScriptOrModule_, _specifier_, and _promiseCapability_ and performs the following steps when called:
            1. Assert: _result_ is *undefined*.
            1. Let _moduleRecord_ be ! <span>HostResolveImportedModule</span>(_referencingScriptOrModule_, _specifier_).
            1. Assert: Evaluate has already been invoked on _moduleRecord_ and successfully completed.
            1. Let _namespace_ be Completion(GetModuleNamespace(_moduleRecord_)).
            1. If _namespace_ is an abrupt completion, then
              1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _namespace_.[[Value]] &raquo;).
            1. Else,
              1. Perform ! Call(_promiseCapability_.[[Resolve]], *undefined*, &laquo; _namespace_.[[Value]] &raquo;).
            1. Return ~unused~.
          1. Let _onFulfilled_ be CreateBuiltinFunction(_fulfilledClosure_, 0, *""*, &laquo; &raquo;).
          1. Let _rejectedClosure_ be a new Abstract Closure with parameters (_error_) that captures _promiseCapability_ and performs the following steps when called:
            1. Perform ! Call(_promiseCapability_.[[Reject]], *undefined*, &laquo; _error_ &raquo;).
            1. Return ~unused~.
          1. Let _onRejected_ be CreateBuiltinFunction(_rejectedClosure_, 0, *""*, &laquo; &raquo;).
          1. Perform PerformPromiseThen(_innerPromise_, _onFulfilled_, _onRejected_).
          1. Return ~unused~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-GetImportedModule" type="abstract operation">
        <h1>
          <ins>
            GetImportedModule (
              _referrer_: a Cyclic Module Record,
              _specifier_: a String,
            ): a Module Record or ~empty~
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. If _referrer_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is _specifier_, then
            1. Return _record_.[[Module]].
          1. Return ~empty~.
        </emu-alg>
      </emu-clause>

      <emu-clause id="sec-LoadImportedModule" type="abstract operation">
        <h1>
          <ins>
            LoadImportedModule (
              _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
              _specifier_: a String,
              _state_: a ModuleLoadState Record,
            ): ~unused~
          </ins>
        </h1>
        <dl class="header">
          <dt>description</dt>
          <dd></dd>
        </dl>

        <emu-alg>
          1. If _referrer_.[[LoadedModules]] contains a Record _record_ such that _record_.[[Specifier]] is _specifier_, then
            1. Perform DispatchLoadImportedModuleContinuation(_state_, NormalCompletion(_result_.[[Module]])).
          1. Else if _referrer_.[[LoadingModules]] contains a Record _record_ such that _record_.[[Specifier]] is _specifier_, then
            1. Add _state_ to _record_.[[LoadStates]].
          1. Else,
            1. Add Record { [[Specifier]]: _specifier_, [[LoadStates]]: &laquo; _state_ &raquo; } to _referrer_.[[LoadingModules]].
            1. Perform HostLoadImportedModule(_referrer_, _specifier_, _state_.[[HostDefined]]).
        </emu-alg>

        <emu-clause id="sec-HostLoadImportedModule" type="host-defined abstract operation">
          <h1>
            <ins>
              HostLoadImportedModule (
                _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
                _specifier_: a String,
                _hostDefined_: anything,
              ): ~unused~
            </ins>
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>

          <emu-note>
            <p>An example of when _referrer_ can be a Realm Record is in a web browser host. There, if a user clicks on a control given by</p>

            <pre><code class="html">&lt;button type="button" onclick="import('./foo.mjs')"&gt;Click me&lt;/button&gt;</code></pre>

            <p>there will be no active script or module at the time the <emu-xref href="#sec-import-calls">`import()`</emu-xref> expression runs. More generally, this can happen in any situation where the host pushes execution contexts with *null* ScriptOrModule components onto the execution context stack.</p>
          </emu-note>

          <p>An implementation of HostLoadImportedModule must conform to the following requirements:</p>
          <ul>
            <li>
              The host environment must perform FinishLoadImportedModule(_referrer_, _specifier_, _result_), where _result_ is either a normal completion containing the loaded Module Record or a throw completion, either synchronously or asynchronously.
            </li>
          </ul>

          <p>The actual process performed is host-defined, but typically consists of performing whatever I/O operations are necessary to load the appropriate Module Record. Multiple different (_referrer_, _specifier_) pairs may map to the same Module Record instance. The actual mapping semantic is host-defined but typically a normalization process is applied to _specifier_ as part of the mapping process. A typical normalization process would include actions such as expansion of relative and abbreviated path specifiers.</p>
        </emu-clause>

        <emu-clause id="sec-FinishLoadImportedModule" type="abstract operation">
          <h1>
            <ins>
              FinishLoadImportedModule (
                _referrer_: a Script Record, a Cyclic Module Record, or a Realm Record,
                _specifier_: a String,
                _result_: either a normal completion containing a Module Record or a throw completion,
              ): ~unused~
            </ins>
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>
          <emu-alg>
            1. If _result_ is a normal completion, then
              1. Assert: _referrer_.[[LoadedModules]] does not contain a Record _record_ such that _record_.[[Specifier]] is _specifier_.
              1. Add Record { [[Specifier]]: _specifier_, [[Module]]: _result_.[[Value]] } to _referrer_.[[LoadedModules]].
            1. Assert: _referrer_.[[LoadingModules]] contains a Record whose [[Specifier]] field is _specifier_.
            1. Let _entry_ be the Record in _referrer_.[[LoadingModules]] whose [[Specifier]] field is _specifier_.
            1. Remove _entry_ from _referrer_.[[LoadingModules]].
            1. For each ModuleLoadState Record _state_ in _entry_.[[LoadStates]], do
              1. Perform DispatchLoadImportedModuleContinuation(_state_, _result_).
          </emu-alg>
        </emu-clause>

        <emu-clause id="sec-DispatchLoadImportedModuleContinuation" type="abstract operation">
          <h1>
            <ins>
              DispatchLoadImportedModuleContinuation (
                _state_: a ModuleLoadState Record,
                _result_: either a normal completion containing a Module Record or a throw completion,
              ): ~unused~
            </ins>
          </h1>
          <dl class="header">
            <dt>description</dt>
            <dd></dd>
          </dl>
          <emu-alg>
            1. If _state_.[[Action]] is ~graph-loading~, then
              1. Perform ContinueModuleLoading(_state_, _result_).
            1. Else,
              1. Perform ContinueDynamicImport(_state_, _result_).
          </emu-alg>
        </emu-clause>
      </emu-clause>
    </emu-clause>
  </emu-clause>
</emu-clause>
